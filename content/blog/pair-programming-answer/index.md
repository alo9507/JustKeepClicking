---
title: Pair Programming in the The Race to Release | Part 2
date: "2020-01-13T22:12:03.284Z"
description: "What part of the software development equation does pairing improve?"
---

<i>This is Part II of Pair Programming in the The Race to Release.</i>

Read [Part I](/pair-programmaing-in-the-race-to-release/) first for full effect.

<h2>Pair Programming and Time To Release</h2>

Here's the equation we arrived at in Part I:

<img src="./FinalEquation.svg" alt="final_equation" class="equation">

We asked the questions:

<blockquote>Why would I pay two developers to do the job of one?</blockquote>

and

<blockquote>How does pair programming effect time to release?</blockquote>

Here we venture an answer:

<blockquote><b>ANSWER</b>: Pairing has the potential to directly MAXIMIZE the bottom (i.e. human) part of the TTR equation, resulting in second order consequences that MINIMIZE the top half of the TTR equation.</blockquote>

Let's look at what factors pairing has a push and pull effect.

<h2>Upskilling Opportuntiies</h2>

<h3>The Good</h3>

Pairing provides ample upskilling opportunities every minute of every day. Pair programming makes knowledge transfer and onboarding a near inevitability.

Many developers value on-the-job professional development opportunities very highly. This makes companies with pair programming cultures highly attractive to both junior developers as well as intermediate or senior developers entering a new software engineering discipline. Certain breeds of senior devs of course enjoy pairing with other senior devs as well.

<b>The Bad:</br>

<b>Distraction to Experienced Devs:</b>The raw hours that developers with high skill weightings spend actually coding in a healthy pair programming culture is by necesssity less than it would be otherwise. Some time is diverted away from coding and devoted to explaining what they're doing and why they're doing it to other developers.

Some time will be spent talking rather than typing.

<h2>Skill Weighting</h2>

<b>Pair Programming Changes How You Hire</b> This is not bad in itself, but it may exclude certain anti-social or even misanthropic geniuses with very high individual skill weightings from joining you organization. 10x Engineers glow on the surface, but they have [one unfortunate characteristic](/the-problem-with-10x-engineers/) that could crush your product.

Though a healthy pairing culture may preclude the hiring of a certain breed of irascible genius 10x Engineers, it is still the best way to provide literally constant upskilling opportunities to all developers on the project.

<h2>Codebase Familiarity</h2>

<h3>The Good</h3>

Devs talk shop. The conversations that take place organically during pairing and exploring the codebase lead to a healthy breadth-first familiarity with the entire codebase with good pairing rotations.

<h3>The Bad</h3>

<b>Developers May be Slightly Less Specialized</b> Both a blessing and a curse, depth-first specialization and familiarity in certain parts of the codebase can boost developer efficiency for tasks in those areas. Without pair rotations, it often happens that one developer develops a deep familiarity, a kind of intellectual marriage, to one part of the codebase that they solo-coded at some point. Other developers begin avoiding that area, happy to just let the original author handle any issue that arises in their personal enclave of the codebase.

This kind of specialization is efficient but dangerous. It is efficient in the short term to just let Dr. I-Wrote-this-Code whip out bug fixes, but in the mid to long term, this often causes idiosyncratic, ad hoc and quirky code. Isolation breeds individuality, and in a codebase individuality is really quirks. A quirky codebase is the last thing you want.

This can of course be offset with intentional user story rotations.

<h2>The Only Thing that Matters: Who Wins this Debate?</h2>

Just kidding.

Some devs like pairing all the time. Some like pairing most of the time. Some like pairing less of the time. Some donâ€™t like pairing at all.

They are all correct.

I happen to be a social dev. My entire career except for a few months has been within pair programming cultures. I prefer rabbit holing with my headphones on for hours, getting lunch, then popping out and sharing what I made in a good pairing session. My personal preferred work routine would be 3 days pairing and 2 days solo coding, to be decided by me and my pair in our iteration planning meeting.

That's all! LMK what your take is on pairing in the comments, and any additional factors I missed in the Time-to-Release Equation. Everything on here is a living document.
